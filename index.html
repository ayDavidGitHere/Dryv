<html>
	<head> 
		<link rel="icon" type="image/png" sizes="16x16" href="https://avatars.githubusercontent.com/u/71327146?v=4">
      <link rel="stylesheet" type="text/css" href="./index.css" />


      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
		<link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Oswald:wght@700&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet"> 
		<link href="https://fonts.googleapis.com/css2?family=Raleway:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

		<style>

html {
  width: auto; 
}
body {
   width: 100%; height:  100%; 
   margin: 0; padding: 0;
	background-color: var(--col-primary);
	font-family: 'Raleway', sans-serif;
}
body { 
	--col-primary: #111111;
	--col-primary-plus: #222222;
	--col-primary-plus-blue: #222233;
	--col-secondary: #eeeeee;
	--col-accent: blueviolet;
	--col-accent-2: #221144;
	--col-accent-3: #eecc44;
}
body[light] {
	--col-primary: #eeeeee;
	--col-primary-plus: #dddddd;
	--col-primary-plus-blue: #ddddcc;
	--col-secondary: #111111;
	--col-accent: blueviolet;
}
body * {
	color: var(--col-secondary);
}






@media only screen and (max-width: 767px) {
	html { 
		font-size: 13px;
	}
}










header {

}
header nav {
	width: 100%;
	height: 80px;
	display: flex;
	box-sizing: border-box;
	padding: 30px;
	padding-left: 12.5%;
	padding-right: 12.5%;

	flex-flow: row wrap;
	justify-content: space-between; 
	position: fixed; top: 0px; 
	background-color: transparent;
} 

body[footer-in-view] header nav {
	display: none;
}

highlight {
	color: var(--col-accent);
}

header {
  z-index: 2;
}

header nav img.nav-logo {

}

header nav .nav-title { 
	margin-right: 20px;
}

header nav .nav-links { 
	flex-grow: 1;
	flex-shrink: 0;
	flex-basis: 200px;
}

header nav .nav-links {
	margin: 0;
	padding: 0;
}

header nav .nav-links li {
	margin-left: 5px;
	margin-right: 5px;
	padding-left: 5px;
	padding-right: 5px; 
	padding-bottom: 5px;
	display: inline-block;
	list-style: none;
}

header nav .nav-links li:hover {
	border-bottom: 2px solid var(--col-accent);
}

header nav .nav-links li a {
	text-decoration: none;
}


header nav .nav-right {

}






section[pg-1] {
	width: 100%; height: 100%; 
	display: flex;
	flex-flow: row wrap;
	box-sizing: border-box;
	justify-content: space-between;
	padding-left: 12.5%;
	padding-right: 12.5%;
	padding-top: calc(80px); 
  
	pointer-events: none;
}


section[pg-1] .top-sect {
	width: 100%; height: 100%;
	overflow: hidden;
	box-sizing: border-box;  
	padding-top: 5%;
	text-align: center;

	z-index: 1;
}

section[pg-1] .top-sect .header-text{
	font-size: 2rem;
	font-weight: bold; 
	line-height: 2.5rem; 
	margin: 0;
	padding: 0;
	color: var(--col-secondary);

	pointer-events: auto;
}

section[pg-1] .top-sect .header-text-1{
	font-size: 3rem;  
}

section[pg-1] .top-sect .header-text-2{
	font-size: 1rem;  
}

section[pg-1] .top-sect .header-text-3{
	font-size: .71rem; 
	line-height: .51rem; 
}

section[pg-1] .top-sect .header-links {
	margin-top: 40px;

	pointer-events: auto;
}

section[pg-1] .top-sect .link-1 {
	padding: 10px 20px; 
	background-color: transparent;
	color: var(--col-secondary);
	border: 1px solid var(--col-secondary);
	border-radius: 30px;
}

section[pg-1] .top-sect .link-2 {
	padding: 10px 20px;  
	border-radius: 5px;
}

section[pg-1] .top-sect .header-links a {
	text-decoration: none;
}

section[pg-1] .top-sect .header-links i {
	color: inherit;
}

section[pg-1] .top-sect .header-links a:hover {
	color: var(--col-accent-3);
	background-color: transparent;
	border: .3px solid var(--col-accent-3);
}




section[anim-sect] {
	position: absolute;
	top: 0; left: 0;
	width: 100%; height: 100%;
	box-sizing: border-box;
	background-color: var(--col-accent-2);
}


		</style>
	</head>
	<body>
		<section anim-sect>
			
		</section>
		<header>
			<nav>
			    <img class="nav-logo" src=""></img>
			    <span class="nav-title">Choose car &nbsp; <i class="fas fa-arrow-right"> </i></span>
			    <ul class="nav-links">
			        <li><a href="">KyoSera</a></li>
			        <li><a href="">Mustang</a></li>
			        <li><a href="">Sonata</a></li>
			        <li><a href="">Nord</a></li>
			    </ul>
			    <div class="nav-right">
			        <span>Dryv</span>
			    </div>
			</nav>
		</header>
		<section pg-1>
		    <div class="top-sect">
		        <p class="header-text header-text-1">DRYV  <br> IMMERSIVELY.</p>
		        <p class="header-text header-text-2">With anybody, anyone, around the world</p>
		        <p class="header-text header-text-3">123</p>
		        <p class="header-links">
		            <a class="link-1">Choose Car &nbsp; &nbsp;<i class="fas fa-arrow-up"> </i></a> 
		        </p>
		    </div> 
		</section> 
	</body>
	<script type="text/javascript"> 
	let page = document.body;
	const footer = document.querySelector('footer');


	</script>

   <script type="importmap">
	{
	  "imports": {
	    "three": "https://unpkg.com/three@latest/build/three.module.js",
	    "OrbitControls": "https://unpkg.com/three@latest/examples/jsm/controls/OrbitControls.js",
	    "OBJLoader": "https://unpkg.com/three@latest/examples/jsm/loaders/OBJLoader.js",
	    "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
	  }
	}
   </script>
	<script type="module">
	    import * as THREE from 'three';
	    import { OrbitControls } from 'OrbitControls';
	    import { OBJLoader } from 'OBJLoader';
	    import { mergeGeometries } from "three/addons/utils/BufferGeometryUtils.js";

	    let scene, camera, drivebyCamera, tpCamera, testBall, renderer, controls;


	    let env = {};
	    window.threejs_env = env;
	    function init() {
	      // Scene
	      scene = new THREE.Scene();
	      scene.background = new THREE.Color(0x221144); 

	      // Camera
	      drivebyCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
	      tpCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
	      tpCamera.position.y += 1;

	      camera = drivebyCamera;
	      camera.position.z = 5;
	      camera.position.x += 15;
	      camera.position.z += 14;

	      // Renderer
	      renderer = new THREE.WebGLRenderer({ antialias: true });
	      renderer.setSize(window.innerWidth, window.innerHeight);
	      document.body.querySelector("section[anim-sect]").appendChild(renderer.domElement);
	      addAnimSectElement();

	      // Lighting
	      const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
	      scene.add(ambientLight);

	      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
	      directionalLight.position.set(5, 10, 7.5);
	      scene.add(directionalLight);

	      // Controls
	      controls = new OrbitControls(camera, renderer.domElement);
	      controls.enableDamping = true;
	      controls.dampingFactor = 0.05;
	      controls.screenSpacePanning = false;
	      controls.maxPolarAngle = Math.PI / 2;



	      let trackScene = new THREE.Group();
	      scene.add(trackScene);

		  	let trackPerimeter = 4 * 2;
		  	let trackWidth = 0.85 * 2;

				const boxSize = (trackPerimeter - trackWidth / 2);


	      const testBallGeo = new THREE.BoxGeometry(1/7, 1/7, 1/5);
				const testBallGeoMaterial =	new THREE.MeshStandardMaterial({ 
					  color: 0xccaadd,// Dark purple color 
					  emissive: 0x000000,
					  roughness: 1.0, 
					  metalness: 1.0, 
					  side: THREE.DoubleSide,
					  flatShading: true,
					});
				testBall = new THREE.Mesh(testBallGeo, testBallGeoMaterial);
	      //trackScene.add(testBall);

				const skySphereGeo = new THREE.SphereGeometry(boxSize * 10, 64, 64); 
				const skySphereMaterial = new THREE.ShaderMaterial({
				  uniforms: {
				    topColor: { value: new THREE.Color(0x191970) },
				    bottomColor: { value: new THREE.Color(0xEE82EE) },
				  },
				  vertexShader: `
				    varying vec3 vPosition;
				    void main() {
				      vPosition = position;
				      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				    }
				  `,
				  fragmentShader: `
				    uniform vec3 topColor;
				    uniform vec3 bottomColor;
				    varying vec3 vPosition;
				    void main() {
				      float factor = (vPosition.y + 100.0) / 200.0;
				      gl_FragColor = vec4(mix(bottomColor, topColor, factor), 1.0);
				    }
				  `,
				  side: THREE.BackSide,
				});
				const skySphere = new THREE.Mesh(skySphereGeo, skySphereMaterial);
				trackScene.add(skySphere);
				 

		    let texture = new THREE.TextureLoader().load(
			  	'violet-transparent-skyline.png');
		    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			  texture.offset.set(0, 0);  
		    texture.repeat.set(3, 1)
				let skyLineMaterial = new THREE.MeshBasicMaterial({
					  map: texture, 
					  transparent: true,  
						side: THREE.DoubleSide,
						opacity: .01,
				  });
				let skyLineMaterials = [skyLineMaterial, skyLineMaterial, skyLineMaterial, skyLineMaterial, skyLineMaterial, skyLineMaterial];
				skyLineMaterials[2] = skyLineMaterials[3] = new THREE.MeshBasicMaterial({
					  transparent: true,
						color: 0x000000,
						opacity: 0,
				  });
				let skyLineWidth = boxSize * 1.82;
				let skyLineLength = boxSize * 1.82;
				let skyLineGeo = new THREE.BoxGeometry(skyLineWidth, boxSize/4, skyLineLength);
				const skyLine = new THREE.Mesh(skyLineGeo, skyLineMaterials);
				trackScene.add(skyLine); 



				const skyLinePlaneWidth = boxSize * 2.5;
				const skyLinePlaneMaterials =	new THREE.MeshStandardMaterial({ 
					  color: 0x772299,// Dark purple color 
					  emissive: 0x000000,
					  roughness: 1.0, 
					  metalness: 1.0, 
					  side: THREE.DoubleSide,
					  flatShading: true,
					});
				 
				const skyLinePlaneGeo = new THREE.PlaneGeometry(skyLinePlaneWidth, skyLinePlaneWidth);
				const skyLinePlane = new THREE.Mesh(skyLinePlaneGeo, skyLinePlaneMaterials);
				skyLinePlane.rotation.x += Math.PI/2;
				skyLinePlane.position.x += skyLinePlaneWidth/2;
				skyLinePlane.position.z += skyLinePlaneWidth/2;
				skyLinePlane.position.y = -1.2 ;

				trackScene.add(skyLinePlane); 	 


				const mainSpotLight = new THREE.SpotLight(0xaacc99, 5)
				mainSpotLight.position.set(0, 5, 0);
				mainSpotLight.target = new THREE.Object3D(skyLinePlaneWidth, 2, skyLinePlaneWidth);

				//trackScene.add(mainSpotLight, mainSpotLight.target);






	      // Load .obj model
	      const objLoader = new OBJLoader();
	      objLoader.load(
	        'Koenigsegg.obj',  
	        function (object) {
	          object.scale.set(1/40, 1/40, 1/40); 

	          object.position.set(0, 0, 0);
	          trackScene.add(object);
	          env.carObj = object;

	          env.carObj2 = object.clone();
	          trackScene.add(env.carObj2);

	          env.carObj3 = object.clone();
	          trackScene.add(env.carObj3);

				    designCar();
				    driftCar(0);
	        },
	        // Progress callback
	        function (xhr) {
	          //console.log((xhr.loaded / xhr.total * 100) + '% loaded');
	        },
	        // Error callback
	        function (error) {
	          console.log('An error occurred while loading the OBJ file', error);
	        }
	      ); 



			  function createPlane(){
			  	let tP = trackPerimeter;
			  	let sP = tP + tP/2;
					const curvePoints =  [
						-tP, -1, -tP,  
						+tP, -1, -tP, 
						+tP, -1, +tP,
						-tP, -1, +tP,

						-tP, -1, 0,
						-sP, -1, 0,
						-sP, -1, -tP,  

						-tP, -1, -tP,
						];  

					const pts = [];
					for ( let i = 0; i < curvePoints.length; i += 3 ) {
						pts.push( new THREE.Vector3( curvePoints[ i ], curvePoints[ i + 1 ], curvePoints[ i + 2 ] ) );
						
					}
					const ls = 1400; // length segments
					const ws = 5; // width segments 
					const lss = ls + 1;
					const wss = ws + 1;

					const curve = new THREE.CatmullRomCurve3( pts );
					const points = curve.getPoints( ls );
					const len = curve.getLength( );
					const lenList = curve.getLengths ( ls );

					const faceCount = ls * ws * 2;
					const vertexCount = lss * wss;

					const indices = new Uint32Array( faceCount * 3 );
					const vertices = new Float32Array( vertexCount * 3 );
					const uvs = new Float32Array( vertexCount * 2 );

					const g = new THREE.BufferGeometry( );
					g.setIndex( new THREE.BufferAttribute( indices, 1 ) );	
					g.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
					g.setAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

					let idxCount = 0;
					let a, b1, c1, c2;

					for ( let j = 0; j < ls; j ++ ) {
						for ( let i = 0; i < ws; i ++ ) {
							// 2 faces / segment,  3 vertex indices
							a =  wss * j + i;
							b1 = wss * ( j + 1 ) + i;		// right-bottom
							c1 = wss * ( j + 1 ) + 1 + i;
						//  b2 = c1							// left-top
							c2 = wss * j + 1 + i;
							indices[ idxCount     ] = a; // right-bottom
							indices[ idxCount + 1 ] = b1;
							indices[ idxCount + 2 ] = c1; 
							
							indices[ idxCount + 3 ] = a; // left-top
							indices[ idxCount + 4 ] = c1 // = b2,
							indices[ idxCount + 5 ] = c2; 
							
							g.addGroup( idxCount, 6, i ); // write group for multi material
							
							idxCount += 6;
						}
					}

					let uvIdxCount = 0;

					for ( let j = 0; j < lss ; j ++ ) {
						for ( let i = 0; i < wss; i ++ ) {
							uvs[ uvIdxCount     ] = lenList[ j ] / len;
							uvs[ uvIdxCount + 1 ] = i / ws;
							
							uvIdxCount += 2;
						}
					}

					let x, y, z;
					let posIdx = 0; // position index

					let tangent;
					const normal = new THREE.Vector3( );
					const binormal = new THREE.Vector3( 0, 1, 0 );
					 
					const t = []; // tangents
					const n = []; // normals
					const b = []; // binormals

					for ( let j = 0; j < lss; j ++ ) { 
						tangent = curve.getTangent(  j / ls );
						t.push( tangent.clone( ) );
						
						normal.crossVectors( tangent, binormal );
						
						normal.y = 0; // to prevent lateral slope of the road
						
						normal.normalize( );
						n.push( normal.clone( ) );
						
						binormal.crossVectors( normal, tangent ); // new binormal
						b.push( binormal.clone( ) );	
					}

					let trackBord = 0;
					const dw = [ 
						-(trackWidth+trackBord), -trackWidth/1.2, 
						-0.05, 0.05, 
						trackWidth/1.2, (trackWidth+trackBord)
						]; // width from the center line

					for ( let j = 0; j < lss; j ++ ) {  // length
						for ( let i = 0; i < wss; i ++ ) { // width
							x = points[ j ].x + dw[ i ] * n[ j ].x;
							y = points[ j ].y;
							z = points[ j ].z + dw[ i ] * n[ j ].z;		 
							
							vertices[ posIdx ] = x;
							vertices[ posIdx + 1 ] = y;
							vertices[ posIdx + 2 ] = z;
							
							posIdx += 3;
						}
					}

					//const tex = new THREE.TextureLoader( ).load( 'CentralMarking.png' );
					//tex.wrapS = THREE.RepeatWrapping;
					//tex.repeat.set( ls * 2); 


					const trackDarkMaterial = new THREE.MeshStandardMaterial({ 
					  color: 0x441166,// Dark purple color 
					  emissive: 0x000000,
					  emissiveIntensity: .19,	
					  roughness: 1.0, 
					  metalness: 1.0, 
					  side: THREE.DoubleSide,
					  flatShading: true,
					});



					const material = [
						new THREE.MeshStandardMaterial( { color: 0xaa33ff, side: THREE.DoubleSide, roughness: 0.0, metalness: 0, flatShading: true, emissive: 0x000000,   } ),
						trackDarkMaterial,  
						new THREE.MeshStandardMaterial( { color: 0xaa8844, side: THREE.DoubleSide, emissive: 0x000000, flatShading: true, } ),
						trackDarkMaterial,
						new THREE.MeshStandardMaterial( { color: 0xaa33ff, side: THREE.DoubleSide, roughness: 0.0, metalness: 0, flatShading: true, emissive: 0x000000,   } ),
					];

					const roadMesh = new THREE.Mesh( g, material );
					roadMesh.position.x += trackPerimeter;
					roadMesh.position.z += trackPerimeter;
					trackScene.add( roadMesh );
					//trackScene.rotation.y += Math.PI/3;
					env.roadPath = roadMesh;


					const M3 = new THREE.Matrix3( );
					const M4 = new THREE.Matrix4( ); 

					this.autoDriveOnPlane = function ( raceCar, whichCar = 1 ) { 
						raceCar.trackPosCount = raceCar.trackPosCount ?? 0;
						let iBlue = raceCar.trackPosCount;
						if ( iBlue >= lss ) iBlue = 0; 
						
						if ( iBlue == Math.floor(iBlue)){
							M3.set( 
								t[ iBlue ].x, b[ iBlue ].x, n[ iBlue ].x, 
								t[ iBlue ].y, b[ iBlue ].y, n[ iBlue ].y, 
								t[ iBlue ].z, b[ iBlue ].z, n[ iBlue ].z );
							M4.setFromMatrix3( M3 );
							raceCar.setRotationFromMatrix( M4 );  

							let lastM4rot = raceCar.lastM4rot * -1 * -1;
							raceCar.lastM4rot = raceCar.rotation.y; 

							if (lastM4rot - raceCar.rotation.y < 0 )
								raceCar.rotation.y -= Math.PI/2;
						  else 
								raceCar.rotation.y += Math.PI/2; 

							let rP = raceCar.rp ?? 0;
							raceCar.position.set( 
								points[ iBlue ].x + (0.5+rP) * n[ iBlue ].x + trackPerimeter, 
								points[ iBlue ].y, 
								points[ iBlue ].z + (0.5+rP) * n[ iBlue ].z + trackPerimeter 
								);
						}
						
					  iBlue += raceCar.speedDiff ?? 0;
						raceCar.trackPosCount = iBlue;
					} 

					this.addPointLights = function (  ) {
						// remove lights for mobile,for optimization
					  env.device_is_mobile = /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop|BlackBerry/i.test(navigator.userAgent); 	
					  if (env.device_is_mobile) return;

						for ( let iBlue = 0; lss>iBlue; iBlue += 75 ){
							let raceCar = new THREE.PointLight(0xbbaa88, 1*5, 0, 3);
							trackScene.add(raceCar);

							M3.set( 
								t[ iBlue ].x, b[ iBlue ].x, n[ iBlue ].x, 
								t[ iBlue ].y, b[ iBlue ].y, n[ iBlue ].y, 
								t[ iBlue ].z, b[ iBlue ].z, n[ iBlue ].z );
							M4.setFromMatrix3( M3 );
							//raceCar.setRotationFromMatrix( M4 );  

							let lastM4rot = raceCar.lastM4rot * -1 * -1;
							raceCar.lastM4rot = raceCar.rotation.y; 

							if (lastM4rot - raceCar.rotation.y < 0 )
								raceCar.rotation.y -= Math.PI/2;
						  else
								raceCar.rotation.y += Math.PI/2;

							let rP = 1;
							raceCar.position.set( 
								points[ iBlue ].x + (0.5+rP) * n[ iBlue ].x + trackPerimeter, 
								points[ iBlue ].y+0.2, 
								points[ iBlue ].z + (0.5+rP) * n[ iBlue ].z + trackPerimeter 
								);
						}
					}

					this.addPointLights();

			  }

			  function adjustPlane(){
			  	//env.roadPath.position.y -= 2; 
			  }


			  function updatePlane(){
					//env.roadPath.rotation.x += (Math.PI/2)/15
					//env.roadPath.rotation.z += (Math.PI/2)/15
			  	//env.roadPath.position.y -= 1/30;

					//trackScene.scale.x +=.5/10;
					//trackScene.scale.y +=.5/10;
					//trackScene.scale.z +=.5/10; 

					//trackScene.rotation.y -= (Math.PI/2)/25
					//trackScene.rotation.x -= (Math.PI/2)/25
					//trackScene.rotation.z += (Math.PI/2)/25

			  	if(env.carObj) 
			  	roadPlane.autoDriveOnPlane(env.carObj, 1);
			  	if(env.carObj2) 
			  	roadPlane.autoDriveOnPlane(env.carObj2, 2);
			  	if(env.carObj3) 
			  	roadPlane.autoDriveOnPlane(env.carObj3, 3);

			  	function playCarSpeedby(car, id){
			  		if(!car) return;

				    if( Math.abs(car.position.x - camera.position.x) < 4 )
				    if( Math.abs(car.position.z - camera.position.z) < 4 )
				    	car.playSpeedbySound();	 

			  	}


			  	playCarSpeedby(env.carObj, 0)
			  	playCarSpeedby(env.carObj2)
			  	playCarSpeedby(env.carObj3)


			  	// Update Camera
					camera.position.y = 0 + (env.drivebyCameraControlValue ?? 0 / 1) * 5;

			  	if(false && env.carObj) {
					camera.position.x = env.carObj.position.x +trackWidth * 1; 
					camera.position.z = env.carObj.position.z + trackWidth * 1;
				  }
				} 

				function startTrackSceneAnim(){
					let stopAnim = false;
					let frameCount = 0;
					let fps, fpsInterval, startTime, nowTime, thenTime, elapsedTime;

					env.recordedFps = 20; env.freeFps = false;
					fps = 20; 
					fpsInterval = 1000/fps;
					thenTime = Date.now();
					startTime = thenTime;

					let trackSceneAnim = function(){

					  nowTime = Date.now();
					  elapsedTime = nowTime - thenTime;

					  if(elapsedTime > fpsInterval || env.freeFps) {
					  	thenTime = nowTime - (elapsedTime % fpsInterval);
					  	setCarsFps();
					  	updatePlane();

					  	env.recordedFps = 1000/elapsedTime;
					  }
					  //document.querySelector(".header-text-3").innerText = Math.round(env.recordedFps);


					  requestAnimationFrame(trackSceneAnim);
					}

					trackSceneAnim();
				}




				let roadPlane = new createPlane();
				startTrackSceneAnim();
				adjustPlane();

				trackScene.position.x -= 4;
				trackScene.position.z -= 1;



				skyLine.position.set(env.roadPath.position.x, -0, env.roadPath.position.z); 
				camera.position.x = env.roadPath.position.x + trackPerimeter - trackWidth * .3; 
				camera.position.z = env.roadPath.position.z + trackPerimeter - trackWidth * 2.9;



	      // Handle window resize
	      window.addEventListener('resize', onWindowResize, false);
	    }

	    function onWindowResize() {
	      camera.aspect = window.innerWidth / window.innerHeight;
	      camera.updateProjectionMatrix();
	      renderer.setSize(window.innerWidth, window.innerHeight);
	    }

	    function updateCamera() {
	    	return;
	    	// Update ThirdPerson Camera
	    	if (!env.carObj) return;
	    	camera = tpCamera;

	    	let car = env.carObj;



				let carQuaternion = car.quaternion.clone(); 
				let zeroYQuaternion = new THREE.Quaternion();  
				// Set the Y rotation to 0 while preserving the X and Z rotations
				zeroYQuaternion.setFromEuler(new THREE.Euler(car.rotation.x, 0, car.rotation.z)); 
				let carRotY = carQuaternion.angleTo(zeroYQuaternion);

	    	tpCamera.position.x = car.position.x +  2 //* Math.cos(carRotY);
	    	tpCamera.position.z = car.position.z +  2 //* Math.sin(carRotY);

	    	testBall.position.x = car.position.x + 1.5 * Math.cos(carRotY);
	    	testBall.position.z = car.position.z + 1.5 * Math.sin(carRotY);
	    	testBall.rotation.y = carRotY;//car.rotation.y < 0 ? (car.rotation.y - Math.PI/2) : car.rotation.y
	    	
	    	tpCamera.lookAt(car.position);
	    	
	    	/*
	    	document.querySelector(".header-text-3").innerText //= (car.rotation.x) + "-" + (car.rotation.y) + "_" + (car.rotation.z)
	    	  //= 2 * Math.sin(car.rotation.y) 
	    	  = carRotY
	    	*/
	    	;
        
        let cry = Math.atan(Math.sin(car.rotation.y) / Math.cos(car.rotation.y))
	    	document.querySelector(".header-text-3").style.transform = `rotate(${180/Math.PI*cry}deg)`;; 
	    }

	    function animate() {
	      requestAnimationFrame(animate); 
	      controls.update(); 
	      renderer.render(scene, camera);
	      updateCamera();
	    }

			function addAnimSectElement() {
			  let overlay = document.createElement('div');
			  document.body.querySelector("section[anim-sect]").appendChild(overlay);
			  overlay.style.width = "100%";
			  overlay.style.height = "100%";
			  overlay.style.position = "absolute";
			  overlay.style.top = 0;
			  overlay.style.left = 0;

			  overlay.innerHTML = `
			    <div 
			      class="drivebyCamera-control" 
			      style="width: 75px; height:150px; border: 0.5px solid white; border-radius: 10px; padding: 5px; box-sizing: border-box; position: absolute; right: 20px; bottom: 20px;">
			      <div 
			        class="dragger"
			        style="width: calc(100% - 10px); height:50%; background-color: white; border-radius: 10px; box-sizing: border-box; position: absolute; left: 5px; bottom: 5px;">
			        <span style="display: inline-block; text-align: center; color: midnightblue; font-size: 12px; width: 100%; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); ">DRAG CAMERA</span>
			      </div>
			    </div>
			  `;

			  const control = overlay.querySelector('.drivebyCamera-control');
			  const dragger = control.querySelector('.dragger');

			  // Drag functionality
			  let isDragging = false;
			  let startY, draggerStartY;
			  let draggerMargin = 5;

			  dragger.addEventListener('mousedown', function (event) {
			    isDragging = true;
			    startY = event.clientY;
			    draggerStartY = dragger.offsetTop;
			    document.body.style.userSelect = 'none'; // Prevent text selection
			  });

			  document.addEventListener('mousemove', function (event) {  
			    if (isDragging) {
			      let deltaY = event.clientY - startY;
			      let controlOffsetHeight = control.offsetHeight - draggerMargin * 2; 
			      let newTop = Math.max(draggerMargin, Math.min(controlOffsetHeight - dragger.offsetHeight, draggerStartY + deltaY));
			      dragger.style.bottom = 'auto'; // Clear bottom style since we're positioning by top
			      dragger.style.top = newTop + 'px';

			      // Calculate percentage dragged
			      let dragPercentage = newTop / (controlOffsetHeight - dragger.offsetHeight);
			      env.drivebyCameraControlValue = 1 - dragPercentage; 
			    }
			  });

			  document.addEventListener('mouseup', function () {  console.log("mouseup");
			    isDragging = false;
			    document.body.style.userSelect = ''; // Restore text selection
			  });

			}




	    init();
	    animate();




			function designCar(){


        function registerCar(car, id){
        	if(!env.cars) env.cars = [];

        	car.cid = id;
        	env.cars.push(car);
        	setCarAudio(car);
        };

				registerCar(env.carObj, 1);
				registerCar(env.carObj2, 2);
				registerCar(env.carObj3, 3);



				let colors = null;
					colors = [0xff0000, 0xffff00, 0xffffff, 0x0000ff, 0x00ffff, 0xff00ff, 0x7744aa, ];

				env.cars.map(car=>{
					if(car.cid == 1)
					colors = [0x330033, 0x4b004b, 0x660066, 0x800080, 0x990099, 0xb300b3, 0xcc00cc];

					if(car.cid == 2)
					colors = [0x8B0000, 0xA52A2A, 0xB22222, 0x7B241C, 0x800000, 0x5C0A0A, 0x4B0000];;
				
					if(car.cid == 3)
					colors = [0x001133, 0x002266, 0x003399, 0x001144, 0x001133, 0x002244, 0x002244];
					// 4 = Car Texture, 6 = Rear Lights, 1 = WindowGlass, 5 = Tires
          
          //console.log("---")
					car.traverse((child) => {
					  if (child.material 
					  	&& child.material.length > 0) { 
					    for (let i=0; child.material.length>i; i++){
					    	let matInd = i;
					    	let mat = child.material[matInd].clone();

					    	mat.color.setHex(colors[matInd]);
					    	mat.reflectivity = 1;
					    	mat.shininess = 1; 
					    	//console.log(i, mat)
					    	child.material[matInd] = mat; 
					    };
					  }
					}); 

				}); //EO env.cars.map
			}




			function setCarsFps(){
				if(env.cars)
				env.cars.map(car=>{
					setCarFps(car);
				})
			}

      function setCarFps(car){
				let id = car.cid;

				// Set Car Speed
				car.speedDiff = Math.round(4 / 10 * env.recordedFps);
				if(id==1) car.speedDiff = Math.round(4 / 10 * env.recordedFps);
				if(id==2) car.speedDiff = Math.round(6 / 10 * env.recordedFps);
				if(id==3) car.speedDiff = Math.round(3 / 10 * env.recordedFps);
      }

			function setCarAudio(car){
			  let id = car.cid 

				// Set Car Audio
				car.speedByAudio = id == 2 ? (new Audio("speeding-swoosh.wav")) : (new Audio("fast-car-drive-by.wav"));
				car.playSpeedbySound = function() {
						if(!car.speedByAudio.paused) return;
						//car.speedByAudio.playbackRate = 0.7 + car.speedDiff * 0.3;
						try{
						car.speedByAudio.play();
					  }
						catch(e){}
				}
			}


	    function driftCar(dir){ 
	    	let dC = (function(dir, car, lim){
		    	if (!car) return;
		    	car.rp = car.rp ?? lim;
		    	if (car.rp + dir > lim + 0.5 ) return;
		    	if (car.rp + dir < lim - 0.5 ) return;	   	

	    		car.rp += dir;	
	    	});

	    	dC(0, env.carObj , -1.0);
	    	dC(0, env.carObj2, +0.5); 
	    	dC(dir, env.carObj3, -1.5); 
	    }





		  let lastMouseX = 0;
		  document.addEventListener('mousemove', function(event) {
		    const currentMouseX = event.clientX; // Get the current X position of the mouse

		    // Determine the direction of the mouse movement
		    if (currentMouseX < lastMouseX) {
		      // Mouse moved left
		      driftCar(-0.1 / 10);
		    } else if (currentMouseX > lastMouseX) {
		      // Mouse moved right
		      driftCar(+0.1 / 10);
		    }

		    // Update lastMouseX to the current position
		    lastMouseX = currentMouseX;
		  });

	</script>

</html>